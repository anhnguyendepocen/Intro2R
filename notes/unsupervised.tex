
\chapter{Unsupervised Learning}

\label{sec:unsupervised}

Unlike Supervised Learning, in Unsupervised Learning there is no outcome variable. 
There is thus no notion of ``right'' and ``wrong''. 
We merely want to learn the joint distribution of the data, $x \in \featureS$, and represent it in some way we can understand. 
Well, maybe ``merely'' is not the right word, as learning the joint distribution of the data means that instead of learning the relation between a set $x$ and another, $y$, we now try to learn the relation between all pairs of variables in $x$, which is clearly more challenging. 

Describing the data via it's joint distribution is the pinnacle, but would require many samples if $x$ has a high dimension (by high we mean $p>3$!). For higher dimensions we need to set more modest goals, which vary according to the purpose of the analysis.

The different goals of unsupervised learning can be
\begin{enumerate}
\item \textbf{Density Estimation}: Estimate $\dist(x)$.
\item \textbf{High density regions}: Find feature combinations which tend to concentrate, hopefully, because the belong to homogenous and interpretable subgroups.
\item \textbf{Low dimensional representation}: Find a low dimensional representation of the joint distribution. This allows the learning from realistic sample sizes, and analysis by, e.g., interpretable parameters and visualization.
Since this also serves in supervised learning, it is discussed with more generality in Appendix~\ref{apx:dim_reduce}.
\item \textbf{Cluster}: Assign observation to homogenous groups. In particular, the particular features of an observation are no longer of interest, once it has been assigned to a cluster.
\end{enumerate}


\paragraph{Relation to Supervised Classification}
Learning the joint data distribution, i.e., density estimation, is not only a goal for itself, but can serve for classification. 
The full data generating distribution, in the context of \emph{supervised} learning is called the \emph{generative model}.\marginnote{Generative Model}
See Appendix \ref{apx:generative_concept} for the usage of the estimated generative model for classification.




\section{Cluster Analysis}
\label{sec:cluster_analysis}

In cluster analysis, we aim at assigning observations to (hopefully) homogenous and meaningful clusters. 

Groups identified are called \emph{clusters}, thus these methods are known as \emph{cluster analysis}, or \emph{data segmentation} methods.

Cluster analysis is typically easier than learning a joint distribution (\S\ref{sec:density_estimation}) or even detecting high density regions (\S\ref{sec:high_density}). We will see that for cluster analysis, we don't need the actual features of a data-point; as it will turn out, many methods only require some notion of distance between the points, and not their actual features. 



\subsection{K Means Clustering}
\label{sec:kmeans}
The idea behind K-means clustering is to find a representative point for each of K clusters, and assign each (unlabeled) data point to one of these clusters. As each cluster has a representative point, this is also a \emph{prototype method}.\marginnote{Prototype Methods}.
The clusters are defined so that they minimize the average distance between all points to the center of the cluster.

In K-means, the clusters are first defined, and then similarities computed. This is thus a \emph{top-down} method.\marginnote{Top Down Clustering}

\begin{algorithm}[H]
\caption{K-Means}
\begin{algorithmic}
\State Choose the number of clusters $K$.
\State Arbitrarily assign points to clusters.
\While {Clusters keep changing}
	\State Compute the cluster centers as the average of their points.
	\State Assign each point to its closest cluster center (in Euclidean distance).
\EndWhile
\State \Return Cluster assignments and means.
\end{algorithmic}
\end{algorithm}





\subsection{K-Medoids}
\label{sec:k_medoids}


If a Euclidean distance is inappropriate for a particular $\featureS$, or that robustness to corrupt observations is required, or that we wish to constrain the cluster centers to be actual observations, then the \emph{K-Medoids} algorithm is an adaptation of K-means that allows this.

\begin{algorithm}[H]
\caption{K-Medoids}
\begin{algorithmic}
\State Choose a similarity metric $\similarity(x_i,x_j)$.
\State Choose the number of clusters $K$.
\State Arbitrarily assign points to clusters.
\While {Clusters keep changing}
	\State Within each cluster, set the center as the data point that minimizes the sum of distances to other points in the cluster.
	\State Assign each point to its closest cluster center (in $\similarity(x_i,x_j)$ distance).
\EndWhile
\State \Return Cluster assignments and centers.
\end{algorithmic}
\end{algorithm}


See Section 14.3.10 in \cite{hastie_elements_2003}.




\subsection{Hierarchical Clustering}
\label{sec:hierarchical}
[TODO]




\subsection{Spectral Clustering}
\label{sec:spectral_clustering}
[TODO]






\section{Detect High Density Regions}
\label{sec:high_density}

When data data is high dimensional so that we cannot perform density estimation, or when we are merely interested in grouping observations, we can still detect high density regions where observations ``clump'' together. Hopefully, into meaningful homogenous groups.
The following methods are thus also known a \emph{bump hunting} or \emph{mode finding}.\marginnote{Bump Hunting}
They are all different heuristic algorithms that return high density regions. 

Once high density regions have been detected, they could be assigned to clusters. Then again, assigning to clusters is typically an easier problem which can be solved directly (see \S\ref{sec:cluster_analysis}).



\subsection{Association Rules}
\label{sec:association}
Association rules, or \emph{market basket analysis}, or \emph{affinity analysis}, can be seen as approximating the joint distribution with a region-wise constant function (Eq.~\ref{eq:decision_list}).\marginnote{Market Basket Analysis}
Put differently, we want to capture high density regions of the joint distribution of $x$ with by approximating it with a decision-list (not tree).
Learning a decision-list is a computationally impractical problem in general. Association rules are thus typically learned over binary feature spaces $\featureS$, using heuristic optimization schemes.

This type of problems typically occurs in sales analysis, where vendors seek for combinations of products that tend to sell jointly (so that can design the store better, or discount product bundles).

The \emph{Aprioiri} algorithm \cite{agraval_fast_1994}, is an example of such a heuristic search for high density combinations.\marginnote{Apriori Algorithm}






% % % Density Estimation % % % % 
\section{Density Estimation}
\label{sec:density_estimation}




\subsection{Parametric Density Estimation}
Density estimation deals with the learning of the data generating distribution.
If a parametric generative model can be assumed, this collapses to an unsupervised ERM problem. 
Maximum Likelihood estimation being a particularly attractive approach.
If a parametric model cannot be assumed, we fall into the real of non-parametric methods. As we saw for Supervised learning, these typically rely on pooling information from neighbourhoods of $\featureS$.




\subsection{Kernel Density Estimation}
\label{sec:kernel_density}

Much like the Kernel Regresson regression, a \naive estimator is the moving average.
A natural generalization, in the spirit of the Nadaraya-Watson smoother (Eq.(\ref{eq:nadaraya_watson})) is the \emph{Parzen} estimate:\marginnote{Parzen Estimate}
\begin{align}
\label{eq:parzen}
	\estim{\pdf}(x):=\frac{1}{n \lambda} \sum_{i=1}^n \kernel_\lambda(x,x_i).
\end{align}

\begin{remark}
If you have been convinced by the use of KNN (\S\ref{sec:knn}) for regression (or classification), there is no reason not to use it for density estimation. It will keep offering the same pros and cons as in KNN regression (or classification).
\end{remark}

As previously stated, these methods may fail when $x$ are high dimensional. We thus recur to other methods.











% Generative models %

\section{Generative Models}
\label{sec:generative}

For the mere purpose of making a prediction, we do not need to learn the full data generating distribution $\dist(y,x)$. 
Knowing this distribution, however, does permit to make predictions, via Bayes Theorem: 
$\dist(y|x)=\frac{\dist(y,x)}{\int\dist(y,x)dy}$.
Several supervised and unsupervised methods make use of this relation to make predictions. These are known as \emph{generative models} .
Since the generative distribution serves both in supervised and unsupervised learning, we have dedicated it a section of its own.




\subsection{Density Estimation}
Clearly, the trivial generative model is the density estimation, discussed in Section~\ref{sec:density_estimation}.


\subsection{Fisher's Linear Discriminant Analysis (LDA)}
\label{sec:lda}

The fundamental idea behind Fisher's LDA (sometimes, just LDA) is that for dichotomous $y$'s: $\dist(x|y)$ is multivariate Gaussian, with the same covariance for all $y$.
Estimating $\dist(x|y)$ thus amounts to the estimation of the mean and covariance, which are fairly simple problems that do not require too much data (relatively).

The decision boundaries of this method turn out to be linear in $\featureS$. 
Denoting the distance from the class centers by $\estim{\delta}:=(\estim{\mu}_1-\estim{\mu}_2)$, class thus 2 will be predicted if 
\begin{align}
	x' \estim{\Sigma}^{-1} \estim{\delta} > \frac{1}{2} \estim{\delta}' \estim{\Sigma}^{-1} \estim{\delta}
\end{align}
and class 1 otherwise.


\paragraph{Relation to OLS classification}
Interestingly, the two-class LDA, is the same as a regression classifier from  Section~\ref{sec:regression_classifier} \cite[Eq. 4.11 ]{hastie_elements_2003}.



\subsection{Fisher's Quadratic Discriminant Analysis (QDA)}
\label{sec:qda}
If you are uncomfortable with the fixed covariance assumption of LDA, one can relax thus assumption.
This leads to QDA, which is more flexible than LDA, requiring slightly more data, but permitting the learning of a class of quadratic classifiers, and not only linear.






\subsection{\Naive Bayes}
\label{sec:naive_bayes}

In LDA we dealt with the problem of estimating high dimensional distributions by adding the class-wise Gaussianity assumption. As Gaussians as fairly simple to learn from data, if there is any truth to this assumption, our life improved. 
Another life-simplifying assumption, replacing the Gaussianity assumption, is that $\dist(x|y)$ is the product of the margins, i.e., the the features are independent within each class: $\dist(x|y)=\prod_{j=1}^p\dist(x_j|y)$
This greatly simplifies things as estimating the univariate marginal distributions $\dist(x_j|y)$ is a fairly simple problem, which can be done non-parametrically by Kernel smoothing for continuous predictors (\S\ref{sec:kernel}), and simple relative frequencies for discrete predictors. 




%%%%%%%%% Latent Space Generative Models %%%%%%%%%%%
\subsection{Latent Space Generative Models}
\label{sec:latent_space}

In the Generative Models section (\S\ref{sec:generative}) we deals with methods for supervised and unsupervised learning that explicitly assume the data generating process.
In this section we pursue this idea, but allow the data generating process to depend on some unobservable quantities-- \emph{latent variables}.
The fundamental idea is that while the data generating distribution may have a complicated form, when we condition on the unobserved variable, the distribution greatly simplifies. 

The latent variables define a \emph{state}. This is why these models are also known as \emph{state space} models. A term coined by \citet{kalman_contributions_1960}.\marginnote{State-Space Models}

\subsubsection{Mixtures}
[TODO]


\subsubsection{Regression Switching}
[TODO]



\subsubsection{Factor Analysis (FA)}
\label{sec:factor_analysis}

Factor Analysis is solved very similarly to PCA (\S\ref{sec:pca}), so that the two are often confused and interchanged. 
FA, however, stems from a rather different motivation than PCA.
In can be seen as a descriptive method using some linear algebra properties.
FA is a generative method, estimable using maximum likelihood. In some cases, the two methods can collapse to the same problem. 
We already know this can happen as we have seen that the Linear Regression problem with Gaussian disturbances can collapse to an OLS problem. 

In FA we assume that the observed $X$'s depend linearly on a set of $\rank$ independent latent (i.e. unobservable) attributes we denote with $\latent$.
The generative model is thus
\begin{align}
\label{eq:factor}
	X=\loadings \latent+\varepsilon
\end{align}
Assuming a generative distribution on $\latent$ and $\varepsilon$, we may try to estimate $\loadings \latent$ by maximum likelihood.
Sadly, recovering the particular latent attributes $\latent$ from $\estim{\loadings\latent}$ is still impossible as there are infinitely many such solutions. To see this, consider an orthogonal \emph{rotation} matrix $\rotation$ ($\rotation' \rotation=I$). For each such $\rotation$: $ \loadings \latent=\loadings \rotation' \rotation \latent = \loadings^* \latent^*$.

The choice of $\rotation$ changes the interpretation of the latent attributes. This is why many researchers find FA an unsatisfactory inference tool.



\paragraph{Terminology}
\begin{description}
\item[Factors] The unobserved attributes $\latent$.
\item[Loadings] The $A$ matrix; the contribution of each attribute to the observed $X$.
\item[Rotation] An orthogonal re-combination of the latent attributes $\latent$ and loadings, which changes the interpretation of the result.
\end{description}




\subsubsection{Independent Component Analysis (ICA)}
ICA aims at overcoming the non-uniquness of the latent attributes in FA (\S\ref{sec:factor_analysis}).
The fundamental observation is that the non-uniqueness (i.e., non identifiability of $\latent$) stems from the fact that the independent Gaussian distribution is invariant under rotation. I.e. for $\rv \latent \sim \gauss{0,\sigma^2 I}$ is the same as that of $\rotation \rv \latent$. 
By replacing the Gaussianity assumption on the distribution of $\rv \latent$, by some other multivariate distribution, coordinate-wise independent, we can identify $\latent$. 
This is precisely what ICA does. 

\begin{remark}[Blind Source Separation]
ICA is a popular technique in signal processing, where $\latent$ is actually the signal (e.g. sound) produced by several different sources. Recovering $\latent$ is thus recovering the original signals mixing in the recorded $X$. This is known as \emph{blind source separation}.
\end{remark}

\begin{remark}[ICA and FA]
The solutions to the ICA problem can ultimately be seen as a solution to the FA problem with a particular rotation $\rotation$.
Put differently, by the formulation of the ICA problem, implies a specific rotation so that $\latent$ is identifiable. 
\end{remark}

\paragraph{Mathematics of ICA}
[TODO]

For more on ICA, see \cite{hyvarinen_independent_2000}. 


\subsubsection{Hidden Markov Models (HMM)}
\label{sec:hmm}
[TODO]


\subsubsection{Collaborative Filtering}
\label{sec:collaborative_filtering}
[TODO]



\subsection{Dimensionality Reduction in Unsupervised Learning}
\label{sec:dim_reduce_unsupervised}

The idea of ERM also applies to unsupervised learning.
If $\hyp(x)$ is low dimensional representation of $x$, mapping it to $\manifold$, we would seek some $\hyp$ that does not incur too much loss, on average. I.e., we seek to minimize $\risk(\hyp)$.

As usual, we do not have access to the data generating process of $x$, so we typically content ourselves with the empirical risk minimization.
In the context of unsupervised learing, the empirical risk is known as the \emph{reconstruction error}.\marginnote{Reconstruction Error}

The building blocks of a supervised learning problem where the loss function $\loss$, the hypothesis class $\hypclass$, a regularization level, and the optimization scheme.
In unsupervised learning, we have similar building blocks. We still have some loss function, regularized or not, penalizing for the poor reconstruction of the data. We can still solve an ERM problem, or replace the optimization by some other learning algorithm. The main difference is in that instead of some low dimensional mapping $\hyp:x \mapsto \estim{y}$, we learn a mapping  $\hyp:x \mapsto \estim{x}$.





\subsubsection{Principal Components Analysis (PCA)}
\label{sec:pca}

PCA is such a basic technique, it has been rediscovered and renamed independently in many fields. 
It can be found under the names of \emph{discrete Karhunen–Loève Transform; Hotteling Transform; Proper Orthogonal Decomposition (POD); Eckart–Young Theorem; Schmidt–Mirsky Theorem;  Empirical Orthogonal Functions; Empirical Eigenfunction Decomposition;  Empirical Component Analysis;  Quasi-Harmonic Modes;  Spectral Decomposition;  Empirical Modal Analysis;} and possibly more\footnote{Wikipedia: \url{http://en.wikipedia.org/wiki/Principal_component_analysis} }.
The many names are quite interesting as they offer an insight into the different problems that led to its (re)discovery.

Starting with an example, consider human height and weight data. 
While clearly two dimensional data, you don't really need both to understand how ``big'' are the people in the data. 
This is because, height and weight vary mostly along a single dimension, which can be interpreted as the ``bigness'' of an individual. 
This is why, physicians use the Body Mass Index (BMI) as an indicator of size, instead of a two-dimensional measurement.
Assume you now wish to give each individual a size score, that is a linear combination of height and weight: PCA does just that. It returns the linear combination that has the most variability, i.e., the combination which best distinguishes between individuals. 


\paragraph{Terminology}
PCA has received much attention. As such, it has rich underlying theory and terminology.
Here are some terms needed to understand PCA outputs:
\begin{itemize}
\item[Principal Components] The linear combinations of the features, which best separate between observations. In our example- the ``bigness'' index of each individual. The first components captures the most variance, the second components, the second most-variance, etc. In terms of $\manifold$, the principal components are an orthogonal basis for $\manifold$.
\item[Scores] Synonymous to Principal Components.
\item[Loadings] The weights of each data point in each principal component. In our example, the importance of the height and weight in constructing the ``bigness'' index.
\end{itemize}


\paragraph{Intuition}
Notice we have currently offered two motivations for PCA: 
(i) Find linear combinations that best distinguish between observations, i.e., maximize variance. 
(ii) Find the linear subspace the bets approximates the data.
The reason these two problems are equivalent, is due to the use of the squares error.
Informally speaking, the data has some total variance. This variance can be decomposed into the part captured in $\manifold$, and the part not captured\footnote{Analogous to $SST=SSR+SSE$ in linear regression.}. 
Since the variance in the data consists of sums of squares, minimizing the distance from $X$ to $\manifold$, is the same as maximizing the variance of $X \project \manifold$, since their sum is fixed.


\paragraph{Mathematics of PCA}

PCA seeks to represent $x$ in the simplest manifold possible: a linear subspace. Thus, $\manifold$ is simply a rank $\rank$ linear subspace in $\mathbb{R}^p$.
A low dimensional representation of the points in the data consists of decoding their low dimensional encoding. 
Since we are dealing with linear spaces, encoding and decoding can be represented with matrices. 
We thus denote the encoding operator by $\encode:\featureS \mapsto \reals^\rank$, a $\rank \times p$ matrix.
We also denote the decoding operator by $\decode:\reals^\rank \mapsto \featureS$ , a $p \times \rank$ matrix. 
Our predictor function ($\hyp$) in this case is $\hyp(x_i)=\decode\encode x_i$.
 
The ERM problem:
\begin{align}
\label{eq:PCA}
	\argmin{\decode,\encode}{\frac{1}{n}\sum_i (x_i-\decode\encode x_i)^2} .
\end{align}

Without proof, it turns out that Eq.(\ref{eq:PCA}) has a closed form solution. 
This solution is typically presented using the Singular Value Decomposition (SVD) of $X$ we now define.\marginnote{SVD}
\begin{definition}[SVD]
Any $n \times p$ matrix $X$, can be decomposed into $X=UDV'$ where 
$U$ is an $n \times p$ orthogonal matrix ($U'U=I_p$); 
$D$ is a $p \times p$ diagonal matrix with diagonal elements $d_1 \geq d_2 \geq \dots \geq d_p$;
$V$ is a $p \times p$ orthogonal matrix ($V'V=I_p$).
\end{definition}

The solution to Eq.(\ref{eq:PCA}) is 
\begin{align}
\label{eq:PCA_solution}
	\estim{\encode} =& V_\rank' \\
	\estim{\decode} =& V_\rank,
\end{align}
where $V_\rank$ are the first $\rank$ columns of $V$ in the Singular Value Decomposition of $X$.





\subsubsection{Kernel Principal Component Analysis (kPCA)}
\label{sec:kpca}

Back to the motivating example from the PCA section (\S\ref{sec:pca}): assume we want to construct a ``bigness'' score, that best separates between individuals, but we no longer constrain it to be a linear function of the height and weight.
We could thus try to solve 
\begin{align}
\label{eq:kpca_wrong}
	\argmax{g}{\covn{g(X)}}
\end{align}
where $\covn{g(X)}$ is the empirical covariance of $g$ applied on each individual, i.e., row-wise on $X$.

Alas, just like in the supervised learning problem, without any constraints on $g$, we might overfit \andor not be able to compute $g$ as optimization is done in a infinite dimensional space. 
We also need to recall that if we allow for a $\rank$ dimensional score, then we have to solve Eq.(\ref{eq:kpca_wrong}) $\rank$ times.
We thus have two matters to attend:
(i) We need to constrain $g$ so that it does not overfit.
(ii) We need the problem to be computable.
This is precisely what kPCA does. 
It turns out, that for a particular class of functions $g$, the optimal $g$'s take a simple form. 
The classes of such $g$'s are known as Reproducing Kernel Hilbert Spaces. They are presented in Appendix~\ref{apx:rkhs}.

The fundamental observation allowing the application of RKHS theory, is that the scores in the PCA problem, actually depend only on the similarities between individuals, as measured by their empirical correlation. 
In kPCA we replace the measure of similarity with some other measure called the \emph{kernel}, chosen from a particular class, and then proceed as if we were solving a PCA problem.


\paragraph{Mathematics of kPCA}
[TODO]


\subsubsection{Sparse Principal Component Analysis (sPCA)}
[TODO]



\subsubsection{Multidimensional Scaling (MDS)}
\label{sec:MDS}
[TODO]


\subsubsection{Graphical Models}
\label{sec:graphical_model}
[TODO]



\subsubsection{Self Organizing Maps (SOM)}
SOMs are aimed at learning low dimensional representations of data useful for clustering. 
As such, they take the form of K-means clustering (\S\ref{sec:kmeans}), but not in the original space $\featureS$ but rather in a low dimensional representation $\manifold$.

For more on SOMs see Section 14.4 in \cite{hastie_elements_2003}. 



\subsubsection{Principal Curves}
[TODO]


\subsubsection{ISOmap}
[TODO]


\subsubsection{LLE}
[TODO]



\subsubsection{Random Projections}
[TODO: Johnson-Lindenstrauss Lemma]



\subsubsection{Compressed Sensing}
\label{sec:compressed_sensing}
[TODO]



\subsubsection{Information Bottleneck}
[TODO]


\begin{remark}[Information Bottleneck and ICA]
[TODO]
\end{remark}





